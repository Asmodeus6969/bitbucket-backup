/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : /Users/mcc/work/h/hello/desktop/basic.g
 *     -                            On : 2011-09-05 21:37:10
 *     -                 for the lexer : basicLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "basicLexer.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pbasicLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pbasicLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pbasicLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pbasicLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mSTRING    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mLINEN    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mWHITE    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mPRINT    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mGOTO    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mREM    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mLOAD    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mSAVE    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mRUN    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mCATALOG    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mLIST    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mTRASHY    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mA    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mB    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mC    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mD    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mE    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mF    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mG    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mH    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mI    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mJ    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mK    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mL    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mM    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mN    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mO    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mP    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mQ    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mR    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mS    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mT    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mU    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mV    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mW    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mX    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mY    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mZ    (pbasicLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pbasicLexer ctx);
static void	basicLexerFree(pbasicLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
basicLexerFree  (pbasicLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

static void
basicLexerReset (pbasicLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/Users/mcc/work/h/hello/desktop/basic.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called basicLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pbasicLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pbasicLexer basicLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return basicLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called basicLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pbasicLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pbasicLexer basicLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pbasicLexer ctx; // Context structure we will build and return

    ctx = (pbasicLexer) ANTLR3_CALLOC(1, sizeof(basicLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in basicLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our basicLexer interface
     */
    ctx->mSTRING	= mSTRING;
    ctx->mLINEN	= mLINEN;
    ctx->mWHITE	= mWHITE;
    ctx->mPRINT	= mPRINT;
    ctx->mGOTO	= mGOTO;
    ctx->mREM	= mREM;
    ctx->mLOAD	= mLOAD;
    ctx->mSAVE	= mSAVE;
    ctx->mRUN	= mRUN;
    ctx->mCATALOG	= mCATALOG;
    ctx->mLIST	= mLIST;
    ctx->mTRASHY	= mTRASHY;
    ctx->mA	= mA;
    ctx->mB	= mB;
    ctx->mC	= mC;
    ctx->mD	= mD;
    ctx->mE	= mE;
    ctx->mF	= mF;
    ctx->mG	= mG;
    ctx->mH	= mH;
    ctx->mI	= mI;
    ctx->mJ	= mJ;
    ctx->mK	= mK;
    ctx->mL	= mL;
    ctx->mM	= mM;
    ctx->mN	= mN;
    ctx->mO	= mO;
    ctx->mP	= mP;
    ctx->mQ	= mQ;
    ctx->mR	= mR;
    ctx->mS	= mS;
    ctx->mT	= mT;
    ctx->mU	= mU;
    ctx->mV	= mV;
    ctx->mW	= mW;
    ctx->mX	= mX;
    ctx->mY	= mY;
    ctx->mZ	= mZ;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= basicLexerFree;
    ctx->reset          = basicLexerReset;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}
 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 33:8: ( '\"' (~ ( '\"' ) )+ '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:33:8: ( '\"' (~ ( '\"' ) )+ '\"' )
    // /Users/mcc/work/h/hello/desktop/basic.g:33:10: '\"' (~ ( '\"' ) )+ '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }

        // /Users/mcc/work/h/hello/desktop/basic.g:33:14: (~ ( '\"' ) )+
        {
            int cnt1=0;

            for (;;)
            {
                int alt1=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA1_0 = LA(1);
        	    if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '!')) || ((LA1_0 >= '#') && (LA1_0 <= 0xFFFF)))) 
        	    {
        	        alt1=1;
        	    }

        	}
        	switch (alt1) 
        	{
        	    case 1:
        	        // /Users/mcc/work/h/hello/desktop/basic.g:33:14: ~ ( '\"' )
        	        {
        	            if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= 0xFFFF)) )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleSTRINGEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt1 >= 1 )
        		{
        		    goto loop1;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleSTRINGEx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;

}
// $ANTLR end STRING

//   Comes from: 36:8: ( ( '0' .. '9' ) ( '0' .. '9' | ' ' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINEN
 *
 * Looks to match the characters the constitute the token LINEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINEN(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LINEN;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:36:8: ( ( '0' .. '9' ) ( '0' .. '9' | ' ' )+ )
    // /Users/mcc/work/h/hello/desktop/basic.g:36:10: ( '0' .. '9' ) ( '0' .. '9' | ' ' )+
    {
        // /Users/mcc/work/h/hello/desktop/basic.g:36:10: ( '0' .. '9' )
        // /Users/mcc/work/h/hello/desktop/basic.g:36:11: '0' .. '9'
        {
            MATCHRANGE('0', '9'); 
            if  (HASEXCEPTION())
            {
                goto ruleLINENEx;
            }


        }

        // /Users/mcc/work/h/hello/desktop/basic.g:36:21: ( '0' .. '9' | ' ' )+
        {
            int cnt2=0;

            for (;;)
            {
                int alt2=2;
        	switch ( LA(1) ) 
        	{
        	case ' ':
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt2=1;
        		}
        	    break;

        	}

        	switch (alt2) 
        	{
        	    case 1:
        	        // /Users/mcc/work/h/hello/desktop/basic.g:
        	        {
        	            if ( LA(1) == ' ' || ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleLINENEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt2 >= 1 )
        		{
        		    goto loop2;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleLINENEx;
        	}
        	cnt2++;
            }
            loop2: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINENEx; /* Prevent compiler warnings */
    ruleLINENEx: ;

}
// $ANTLR end LINEN

//   Comes from: 39:7: ( ( ' ' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITE
 *
 * Looks to match the characters the constitute the token WHITE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITE(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITE;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:39:7: ( ( ' ' )+ )
    // /Users/mcc/work/h/hello/desktop/basic.g:39:9: ( ' ' )+
    {
        // /Users/mcc/work/h/hello/desktop/basic.g:39:9: ( ' ' )+
        {
            int cnt3=0;

            for (;;)
            {
                int alt3=2;
        	switch ( LA(1) ) 
        	{
        	case ' ':
        		{
        			alt3=1;
        		}
        	    break;

        	}

        	switch (alt3) 
        	{
        	    case 1:
        	        // /Users/mcc/work/h/hello/desktop/basic.g:39:9: ' '
        	        {
        	            MATCHC(' '); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleWHITEEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt3 >= 1 )
        		{
        		    goto loop3;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWHITEEx;
        	}
        	cnt3++;
            }
            loop3: ;	/* Jump to here if this rule does not match */
        }
        {
             LEXSTATE->channel = HIDDEN; 
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITEEx; /* Prevent compiler warnings */
    ruleWHITEEx: ;

}
// $ANTLR end WHITE

//   Comes from: 44:7: ( P R I N T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRINT
 *
 * Looks to match the characters the constitute the token PRINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRINT(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PRINT;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:44:7: ( P R I N T )
    // /Users/mcc/work/h/hello/desktop/basic.g:44:9: P R I N T
    {
        /* 44:9: P R I N T */
        mP(ctx ); 
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }

        /* 44:9: P R I N T */
        mR(ctx ); 
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }

        /* 44:9: P R I N T */
        mI(ctx ); 
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }

        /* 44:9: P R I N T */
        mN(ctx ); 
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }

        /* 44:9: P R I N T */
        mT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePRINTEx; /* Prevent compiler warnings */
    rulePRINTEx: ;

}
// $ANTLR end PRINT

//   Comes from: 45:6: ( G O T O )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GOTO
 *
 * Looks to match the characters the constitute the token GOTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGOTO(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GOTO;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:45:6: ( G O T O )
    // /Users/mcc/work/h/hello/desktop/basic.g:45:8: G O T O
    {
        /* 45:8: G O T O */
        mG(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleGOTOEx;
        }

        /* 45:8: G O T O */
        mO(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleGOTOEx;
        }

        /* 45:8: G O T O */
        mT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleGOTOEx;
        }

        /* 45:8: G O T O */
        mO(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleGOTOEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGOTOEx; /* Prevent compiler warnings */
    ruleGOTOEx: ;

}
// $ANTLR end GOTO

//   Comes from: 46:5: ( R E M )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REM
 *
 * Looks to match the characters the constitute the token REM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREM(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REM;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:46:5: ( R E M )
    // /Users/mcc/work/h/hello/desktop/basic.g:46:7: R E M
    {
        /* 46:7: R E M */
        mR(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleREMEx;
        }

        /* 46:7: R E M */
        mE(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleREMEx;
        }

        /* 46:7: R E M */
        mM(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleREMEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREMEx; /* Prevent compiler warnings */
    ruleREMEx: ;

}
// $ANTLR end REM

//   Comes from: 47:6: ( L O A D )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOAD
 *
 * Looks to match the characters the constitute the token LOAD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOAD(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LOAD;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:47:6: ( L O A D )
    // /Users/mcc/work/h/hello/desktop/basic.g:47:8: L O A D
    {
        /* 47:8: L O A D */
        mL(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLOADEx;
        }

        /* 47:8: L O A D */
        mO(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLOADEx;
        }

        /* 47:8: L O A D */
        mA(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLOADEx;
        }

        /* 47:8: L O A D */
        mD(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLOADEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLOADEx; /* Prevent compiler warnings */
    ruleLOADEx: ;

}
// $ANTLR end LOAD

//   Comes from: 48:6: ( S A V E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAVE
 *
 * Looks to match the characters the constitute the token SAVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAVE(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SAVE;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:48:6: ( S A V E )
    // /Users/mcc/work/h/hello/desktop/basic.g:48:8: S A V E
    {
        /* 48:8: S A V E */
        mS(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }

        /* 48:8: S A V E */
        mA(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }

        /* 48:8: S A V E */
        mV(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }

        /* 48:8: S A V E */
        mE(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleSAVEEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAVEEx; /* Prevent compiler warnings */
    ruleSAVEEx: ;

}
// $ANTLR end SAVE

//   Comes from: 49:5: ( R U N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RUN
 *
 * Looks to match the characters the constitute the token RUN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRUN(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RUN;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:49:5: ( R U N )
    // /Users/mcc/work/h/hello/desktop/basic.g:49:7: R U N
    {
        /* 49:7: R U N */
        mR(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleRUNEx;
        }

        /* 49:7: R U N */
        mU(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleRUNEx;
        }

        /* 49:7: R U N */
        mN(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleRUNEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRUNEx; /* Prevent compiler warnings */
    ruleRUNEx: ;

}
// $ANTLR end RUN

//   Comes from: 50:9: ( C A T A L O G )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CATALOG
 *
 * Looks to match the characters the constitute the token CATALOG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCATALOG(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CATALOG;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:50:9: ( C A T A L O G )
    // /Users/mcc/work/h/hello/desktop/basic.g:50:11: C A T A L O G
    {
        /* 50:11: C A T A L O G */
        mC(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mA(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mA(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mL(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mO(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }

        /* 50:11: C A T A L O G */
        mG(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleCATALOGEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCATALOGEx; /* Prevent compiler warnings */
    ruleCATALOGEx: ;

}
// $ANTLR end CATALOG

//   Comes from: 51:6: ( L I S T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIST
 *
 * Looks to match the characters the constitute the token LIST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLIST(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LIST;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:51:6: ( L I S T )
    // /Users/mcc/work/h/hello/desktop/basic.g:51:8: L I S T
    {
        /* 51:8: L I S T */
        mL(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLISTEx;
        }

        /* 51:8: L I S T */
        mI(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLISTEx;
        }

        /* 51:8: L I S T */
        mS(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLISTEx;
        }

        /* 51:8: L I S T */
        mT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleLISTEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLISTEx; /* Prevent compiler warnings */
    ruleLISTEx: ;

}
// $ANTLR end LIST

//   Comes from: 53:9: ( . )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRASHY
 *
 * Looks to match the characters the constitute the token TRASHY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTRASHY(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TRASHY;
       
    
    // /Users/mcc/work/h/hello/desktop/basic.g:53:9: ( . )
    // /Users/mcc/work/h/hello/desktop/basic.g:53:12: .
    {
        MATCHANY(); 
        if  (HASEXCEPTION())
        {
            goto ruleTRASHYEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTRASHYEx; /* Prevent compiler warnings */
    ruleTRASHYEx: ;

}
// $ANTLR end TRASHY

//   Comes from: 55:11: ( ( 'a' | 'A' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start A
 *
 * Looks to match the characters the constitute the token A
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mA(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:55:11: ( ( 'a' | 'A' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:55:12: ( 'a' | 'A' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleAEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleAEx; /* Prevent compiler warnings */
    ruleAEx: ;

}
// $ANTLR end A

//   Comes from: 56:11: ( ( 'b' | 'B' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start B
 *
 * Looks to match the characters the constitute the token B
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mB(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:56:11: ( ( 'b' | 'B' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:56:12: ( 'b' | 'B' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleBEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleBEx; /* Prevent compiler warnings */
    ruleBEx: ;

}
// $ANTLR end B

//   Comes from: 57:11: ( ( 'c' | 'C' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start C
 *
 * Looks to match the characters the constitute the token C
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mC(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:57:11: ( ( 'c' | 'C' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:57:12: ( 'c' | 'C' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleCEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleCEx; /* Prevent compiler warnings */
    ruleCEx: ;

}
// $ANTLR end C

//   Comes from: 58:11: ( ( 'd' | 'D' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start D
 *
 * Looks to match the characters the constitute the token D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mD(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:58:11: ( ( 'd' | 'D' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:58:12: ( 'd' | 'D' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleDEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleDEx; /* Prevent compiler warnings */
    ruleDEx: ;

}
// $ANTLR end D

//   Comes from: 59:11: ( ( 'e' | 'E' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start E
 *
 * Looks to match the characters the constitute the token E
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mE(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:59:11: ( ( 'e' | 'E' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:59:12: ( 'e' | 'E' )
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleEEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleEEx; /* Prevent compiler warnings */
    ruleEEx: ;

}
// $ANTLR end E

//   Comes from: 60:11: ( ( 'f' | 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start F
 *
 * Looks to match the characters the constitute the token F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mF(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:60:11: ( ( 'f' | 'F' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:60:12: ( 'f' | 'F' )
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFEx; /* Prevent compiler warnings */
    ruleFEx: ;

}
// $ANTLR end F

//   Comes from: 61:11: ( ( 'g' | 'G' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start G
 *
 * Looks to match the characters the constitute the token G
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mG(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:61:11: ( ( 'g' | 'G' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:61:12: ( 'g' | 'G' )
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleGEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleGEx; /* Prevent compiler warnings */
    ruleGEx: ;

}
// $ANTLR end G

//   Comes from: 62:11: ( ( 'h' | 'H' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H
 *
 * Looks to match the characters the constitute the token H
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:62:11: ( ( 'h' | 'H' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:62:12: ( 'h' | 'H' )
    {
        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEx; /* Prevent compiler warnings */
    ruleHEx: ;

}
// $ANTLR end H

//   Comes from: 63:11: ( ( 'i' | 'I' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start I
 *
 * Looks to match the characters the constitute the token I
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mI(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:63:11: ( ( 'i' | 'I' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:63:12: ( 'i' | 'I' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleIEx; /* Prevent compiler warnings */
    ruleIEx: ;

}
// $ANTLR end I

//   Comes from: 64:11: ( ( 'j' | 'J' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start J
 *
 * Looks to match the characters the constitute the token J
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mJ(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:64:11: ( ( 'j' | 'J' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:64:12: ( 'j' | 'J' )
    {
        if ( LA(1) == 'J' || LA(1) == 'j' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleJEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleJEx; /* Prevent compiler warnings */
    ruleJEx: ;

}
// $ANTLR end J

//   Comes from: 65:11: ( ( 'k' | 'K' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start K
 *
 * Looks to match the characters the constitute the token K
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mK(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:65:11: ( ( 'k' | 'K' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:65:12: ( 'k' | 'K' )
    {
        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleKEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleKEx; /* Prevent compiler warnings */
    ruleKEx: ;

}
// $ANTLR end K

//   Comes from: 66:11: ( ( 'l' | 'L' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start L
 *
 * Looks to match the characters the constitute the token L
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mL(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:66:11: ( ( 'l' | 'L' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:66:12: ( 'l' | 'L' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleLEx; /* Prevent compiler warnings */
    ruleLEx: ;

}
// $ANTLR end L

//   Comes from: 67:11: ( ( 'm' | 'M' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start M
 *
 * Looks to match the characters the constitute the token M
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mM(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:67:11: ( ( 'm' | 'M' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:67:12: ( 'm' | 'M' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleMEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleMEx; /* Prevent compiler warnings */
    ruleMEx: ;

}
// $ANTLR end M

//   Comes from: 68:11: ( ( 'n' | 'N' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start N
 *
 * Looks to match the characters the constitute the token N
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mN(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:68:11: ( ( 'n' | 'N' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:68:12: ( 'n' | 'N' )
    {
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleNEx; /* Prevent compiler warnings */
    ruleNEx: ;

}
// $ANTLR end N

//   Comes from: 69:11: ( ( 'o' | 'O' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start O
 *
 * Looks to match the characters the constitute the token O
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mO(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:69:11: ( ( 'o' | 'O' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:69:12: ( 'o' | 'O' )
    {
        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleOEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleOEx; /* Prevent compiler warnings */
    ruleOEx: ;

}
// $ANTLR end O

//   Comes from: 70:11: ( ( 'p' | 'P' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start P
 *
 * Looks to match the characters the constitute the token P
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mP(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:70:11: ( ( 'p' | 'P' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:70:12: ( 'p' | 'P' )
    {
        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto rulePEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto rulePEx; /* Prevent compiler warnings */
    rulePEx: ;

}
// $ANTLR end P

//   Comes from: 71:11: ( ( 'q' | 'Q' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Q
 *
 * Looks to match the characters the constitute the token Q
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQ(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:71:11: ( ( 'q' | 'Q' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:71:12: ( 'q' | 'Q' )
    {
        if ( LA(1) == 'Q' || LA(1) == 'q' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleQEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleQEx; /* Prevent compiler warnings */
    ruleQEx: ;

}
// $ANTLR end Q

//   Comes from: 72:11: ( ( 'r' | 'R' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start R
 *
 * Looks to match the characters the constitute the token R
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mR(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:72:11: ( ( 'r' | 'R' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:72:12: ( 'r' | 'R' )
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleREx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleREx; /* Prevent compiler warnings */
    ruleREx: ;

}
// $ANTLR end R

//   Comes from: 73:11: ( ( 's' | 'S' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start S
 *
 * Looks to match the characters the constitute the token S
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mS(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:73:11: ( ( 's' | 'S' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:73:12: ( 's' | 'S' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleSEx; /* Prevent compiler warnings */
    ruleSEx: ;

}
// $ANTLR end S

//   Comes from: 74:11: ( ( 't' | 'T' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T
 *
 * Looks to match the characters the constitute the token T
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:74:11: ( ( 't' | 'T' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:74:12: ( 't' | 'T' )
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleTEx; /* Prevent compiler warnings */
    ruleTEx: ;

}
// $ANTLR end T

//   Comes from: 75:11: ( ( 'u' | 'U' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start U
 *
 * Looks to match the characters the constitute the token U
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mU(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:75:11: ( ( 'u' | 'U' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:75:12: ( 'u' | 'U' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleUEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUEx; /* Prevent compiler warnings */
    ruleUEx: ;

}
// $ANTLR end U

//   Comes from: 76:11: ( ( 'v' | 'V' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start V
 *
 * Looks to match the characters the constitute the token V
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mV(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:76:11: ( ( 'v' | 'V' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:76:12: ( 'v' | 'V' )
    {
        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleVEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleVEx; /* Prevent compiler warnings */
    ruleVEx: ;

}
// $ANTLR end V

//   Comes from: 77:11: ( ( 'w' | 'W' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start W
 *
 * Looks to match the characters the constitute the token W
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mW(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:77:11: ( ( 'w' | 'W' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:77:12: ( 'w' | 'W' )
    {
        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleWEx; /* Prevent compiler warnings */
    ruleWEx: ;

}
// $ANTLR end W

//   Comes from: 78:11: ( ( 'x' | 'X' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start X
 *
 * Looks to match the characters the constitute the token X
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mX(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:78:11: ( ( 'x' | 'X' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:78:12: ( 'x' | 'X' )
    {
        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleXEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleXEx; /* Prevent compiler warnings */
    ruleXEx: ;

}
// $ANTLR end X

//   Comes from: 79:11: ( ( 'y' | 'Y' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Y
 *
 * Looks to match the characters the constitute the token Y
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mY(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:79:11: ( ( 'y' | 'Y' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:79:12: ( 'y' | 'Y' )
    {
        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleYEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleYEx; /* Prevent compiler warnings */
    ruleYEx: ;

}
// $ANTLR end Y

//   Comes from: 80:11: ( ( 'z' | 'Z' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Z
 *
 * Looks to match the characters the constitute the token Z
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mZ(pbasicLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // /Users/mcc/work/h/hello/desktop/basic.g:80:11: ( ( 'z' | 'Z' ) )
    // /Users/mcc/work/h/hello/desktop/basic.g:80:12: ( 'z' | 'Z' )
    {
        if ( LA(1) == 'Z' || LA(1) == 'z' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleZEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleZEx; /* Prevent compiler warnings */
    ruleZEx: ;

}
// $ANTLR end Z

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pbasicLexer ctx)
{
    {
        //  /Users/mcc/work/h/hello/desktop/basic.g:1:8: ( STRING | LINEN | WHITE | PRINT | GOTO | REM | LOAD | SAVE | RUN | CATALOG | LIST | TRASHY )
        
        ANTLR3_UINT32 alt4;

        alt4=12;


        {
            int LA4_0 = LA(1);
            if ( (LA4_0 == '"')) 
            {

                {
                    int LA4_1 = LA(2);
                    if ( (((LA4_1 >= 0x0000) && (LA4_1 <= '!')) || ((LA4_1 >= '#') && (LA4_1 <= 0xFFFF)))) 
                    {
                        alt4=1;
                    }
                    else 
                    {
                        alt4=12;    }
                }
            }
            else if ( (((LA4_0 >= '0') && (LA4_0 <= '9')))) 
            {
                switch ( LA(2) ) 
                {
                case ' ':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                	{
                		alt4=2;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == ' ')) 
            {
                alt4=3;
            }
            else if ( (LA4_0 == 'P' || LA4_0 == 'p')) 
            {
                switch ( LA(2) ) 
                {
                case 'R':
                case 'r':
                	{
                		alt4=4;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == 'G' || LA4_0 == 'g')) 
            {
                switch ( LA(2) ) 
                {
                case 'O':
                case 'o':
                	{
                		alt4=5;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == 'R' || LA4_0 == 'r')) 
            {
                switch ( LA(2) ) 
                {
                case 'E':
                case 'e':
                	{
                		alt4=6;
                	}
                    break;
                case 'U':
                case 'u':
                	{
                		alt4=9;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == 'L' || LA4_0 == 'l')) 
            {
                switch ( LA(2) ) 
                {
                case 'O':
                case 'o':
                	{
                		alt4=7;
                	}
                    break;
                case 'I':
                case 'i':
                	{
                		alt4=11;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == 'S' || LA4_0 == 's')) 
            {
                switch ( LA(2) ) 
                {
                case 'A':
                case 'a':
                	{
                		alt4=8;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (LA4_0 == 'C' || LA4_0 == 'c')) 
            {
                switch ( LA(2) ) 
                {
                case 'A':
                case 'a':
                	{
                		alt4=10;
                	}
                    break;

                default:
                    alt4=12;}

            }
            else if ( (((LA4_0 >= 0x0000) && (LA4_0 <= 0x001F)) || LA4_0 == '!' || ((LA4_0 >= '#') && (LA4_0 <= '/')) || ((LA4_0 >= ':') && (LA4_0 <= 'B')) || ((LA4_0 >= 'D') && (LA4_0 <= 'F')) || ((LA4_0 >= 'H') && (LA4_0 <= 'K')) || ((LA4_0 >= 'M') && (LA4_0 <= 'O')) || LA4_0 == 'Q' || ((LA4_0 >= 'T') && (LA4_0 <= 'b')) || ((LA4_0 >= 'd') && (LA4_0 <= 'f')) || ((LA4_0 >= 'h') && (LA4_0 <= 'k')) || ((LA4_0 >= 'm') && (LA4_0 <= 'o')) || LA4_0 == 'q' || ((LA4_0 >= 't') && (LA4_0 <= 0xFFFF)))) 
            {
                alt4=12;
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto ruleTokensEx;
            }
        }
        switch (alt4) 
        {
    	case 1:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:10: STRING
    	    {
    	        /* 1:10: STRING */
    	        mSTRING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:17: LINEN
    	    {
    	        /* 1:17: LINEN */
    	        mLINEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:23: WHITE
    	    {
    	        /* 1:23: WHITE */
    	        mWHITE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:29: PRINT
    	    {
    	        /* 1:29: PRINT */
    	        mPRINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:35: GOTO
    	    {
    	        /* 1:35: GOTO */
    	        mGOTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:40: REM
    	    {
    	        /* 1:40: REM */
    	        mREM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:44: LOAD
    	    {
    	        /* 1:44: LOAD */
    	        mLOAD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:49: SAVE
    	    {
    	        /* 1:49: SAVE */
    	        mSAVE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:54: RUN
    	    {
    	        /* 1:54: RUN */
    	        mRUN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:58: CATALOG
    	    {
    	        /* 1:58: CATALOG */
    	        mCATALOG(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:66: LIST
    	    {
    	        /* 1:66: LIST */
    	        mLIST(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // /Users/mcc/work/h/hello/desktop/basic.g:1:71: TRASHY
    	    {
    	        /* 1:71: TRASHY */
    	        mTRASHY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
